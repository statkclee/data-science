---
layout: page
title: 데이터 과학
subtitle: "요인(Factor) - 범주형 자료형"
author:
    name: xwMOOC
    affiliation: Tidyverse Korea
date: "`r Sys.Date()`"
output:
  html_document: 
    toc: yes
    toc_float: true
    highlight: tango
    number_section: true
    code_folding: show
mainfont: NanumGothic
editor_options: 
  chunk_output_type: console
---
 
``` {r, include=FALSE}
source("tools/chunk-options.R")

knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE,
                    comment="", digits = 3, tidy = FALSE, prompt = TRUE, fig.align = 'center')

```

# 요인 자료형 다루기 [^factor-gss] {#wrangling-factor-dataset}

[^factor-gss]: [Wrangling categorical data in R](https://www.semanticscholar.org/paper/Wrangling-categorical-data-in-R-McNamara-Horton/1064bf4b820a877043a3bfb6c8481b230afc5b2b)

요인(factor, 팩터) 자료형을 다룬다는 것은 다음을 의미한다. 하지만, `Base R`과 `tidyverse` 두가지 방식이 있어 두가지 구문에 대한 이해도 필요하다.

- 요인 수준(factor level)에 대한 라벨(label) 바꿈 &rarr; `forcats::fct_recode`, `dplyr::recode`
- 요인 수준 순서 바꾸기 &rarr; `fct_relevel()`
- 요인 범주수준을 줄이기 &rarr; `if_else()`
- 파생 요인 변수 생성시킴 &rarr; `case_when()`

## 요인 수준별로 라벨 변경 {#change-factor-level-label}

Base R에서 먼저 요인(factor)에 대한 데이터 분석 작업은 `levels()` 함수로 범주를 확인하고 `summary()` 함수로 시작된다.

```{r tidyverse-gss}
library(tidyverse)

# download.file("https://raw.githubusercontent.com/dsscollection/factor-mgmt/master/data/GSScleaned.csv", destfile = "data/GSScleaned.csv")

GSS <- read_csv("https://raw.githubusercontent.com/dsscollection/factor-mgmt/master/data/GSScleaned.csv") %>% 
  mutate_if(is.character, as.factor)

levels(GSS$LaborStatus)
summary(GSS$LaborStatus)
```

요인 수준을 다른 형태로 조정하고 싶은데 `levels(GSS$LaborStatus)[1:5]` 앞에서 5개 범주는 그대로 둔 채로 나머지만 바꾸고자 하는 경우 다음과 같이 코드를 작성한다. 하지만, 이렇게 작성하는 것은 소프트웨어가 부서지기 쉬운(fragile software)의 전형적인 예가 된다.

```{r tidyverse-gss-change-label}
GSS$LaborStatus_backup <- GSS$LaborStatus

levels(GSS$LaborStatus) <- c(levels(GSS$LaborStatus)[1:5],
                             "Temporarily not working",
                             "Unemployed, laid off",
                             "Working full time",
                             "Working part time")

summary(GSS$LaborStatus)
```

또다른 방식으로 다소 코드가 길어지기는 하지만 강건한 방식으로 다음과 같이 코드를 작성할 수 있다. 순서가 아닌 범주가 맞는 경우만 라벨을 바꿔주는 것이라 강건하지만 데이터프레임(`GSS`)이 여러번, 변수(`LaborStatus`)도 중복되어 그다지 읽기 즐거운 코드는 아니다.

```{r robust-but-verbose}
GSS$LaborStatus <- GSS$LaborStatus_backup


GSS$LaborStatus <- as.character(GSS$LaborStatus)
GSS$LaborStatus[GSS$LaborStatus == "Temp not working"] <-
  "Temporarily not working"
GSS$LaborStatus[GSS$LaborStatus == "Unempl, laid off"] <-
  "Unemployed, laid off"
GSS$LaborStatus[GSS$LaborStatus == "Working fulltime"] <-
  "Working full time"
GSS$LaborStatus[GSS$LaborStatus == "Working parttime"] <-
  "Working part time"
GSS$LaborStatus <- factor(GSS$LaborStatus)

summary(GSS$LaborStatus)
```

`dplyr` 팩키지 `recode()` 함수, 혹은 `forcats` 팩키지 `fct_recode()`를 사용해서 범주명을 다른 명칭으로 바꿀 수 있는데 코드가 깔끔한다. 

```{r labor-status-tidyverse}
GSS <- GSS %>%
  mutate(tidyLaborStatus =
    fct_recode(LaborStatus,
           `Temp not working` = "Temporarily not working",
           `Unempl, laid off` = "Unemployed, laid off",
           `Working fulltime` = "Working full time",
           `Working parttime ` =  "Working part time"))

GSS %>% 
  count(tidyLaborStatus2, sort=TRUE)
```


<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 10px;}
</style>
<div class = "blue">

**`trimws()` 함수 사용**

범주가 동일하나 공백문자(whitespace)가 포함된 경우 수작업을 일일이 손대는 대신에 `trimws()` 함수를 사용하면 수월히 범주를 잘 정리할 수 있다.

```{r fct-cats-whitespace}
gender <- factor(c("male ", "male  ", "male   ",   "male"))
levels(gender)

gender <- factor(trimws(gender))
levels(gender)
```

</div>

## 요인 수준 순서 변경 {#change-factor-level-order}

그 다음으로 요인 수준 범주 순서를 바꾸는 것이 많이 사용되는 기능이다.
Base R에서는 알파벳 순으로 요인 수준 범주를 기본디폴트 설정되어 있다. 

```{r change-factor-order}
GSS$BaseOpinionOfIncome <- GSS$OpinionOfIncome
summary(GSS$BaseOpinionOfIncome )
```

상기 순서를 다음과 같이 바꾸어 보자. 즉 소득에 대해서 순위형 범주로 순서를 넣어 정렬시키고자 한다.

Far above average &rarr; Above average &rarr; Average &rarr; Below Average &rarr; Far below average &rarr; Don't know &rarr; No answer &rarr; NA's

`factor()` 함수 내부에 `levels = ` 인자조정을 통해서 범주 순서를 재조정시킬 수 있다. 이와 같이 구문을 작성할 경우 `Average`의 경우 공백 때문에, `Below Average`는 대소문자로 인해 잘못 범주 구분이 되어 숫자가 맞지 않는다.

```{r change-factor-order-fragile}
GSS$BaseOpinionOfIncome <- factor(as.character(GSS$BaseOpinionOfIncome),
         levels = c("Far above average", "Above average", "Average ", "Below Average",
                    "Far below average", "Don't know", "No answer"))
summary(GSS$BaseOpinionOfIncome )
```

소득에 대해서 순위형 범주로 순서를 넣어 정렬시키고자 할 때 다음과 같이 엽기(?)적으로 코딩을 할 수 있다.

<div class = "row">
  <div class = "col-md-6">
**원데이터 범주 순서**

```{r change-factor-order-fragile-number}
badApproach <- GSS$OpinionOfIncome
summary(badApproach)
```

  </div>
  <div class = "col-md-6">
**엽기(?)적 범주 순서**

```{r change-factor-order-fragile-level}
levels(badApproach) <- levels(badApproach)[c(5,1:3,6,4,7)]
summary(badApproach)
```

  </div>
</div>



<div class = "row">
  <div class = "col-md-6">
**원데이터 범주 순서**

```{r change-factor-order-fragile-number2}
library(forcats)
summary(GSS$OpinionOfIncome)
```


  </div>
  <div class = "col-md-6">
**`tidyverse`로 깔끔한 범주 순서 정리**

```{r change-factor-order-tidyverse}
GSS <- GSS %>%
  mutate(tidyOpinionOfIncome =
           fct_relevel(OpinionOfIncome,
                       "Far above average",
                       "Above average",
                       "Average",
                       "Below average",
                       "Far below average"))

summary(GSS$tidyOpinionOfIncome)
```

  </div>
</div>

## 요인 범주수준 줄이기 {#factor-reduce-levels}

범주형 변수를 다룰 때 많이 고려해야 하는 것 중에 하나가 요인 범주 수준을 줄이는 것이다. 
예를 들어, 결혼 상태에 대한 다양한 경우의 수가 존재한다. 이를 혼인(`Married`)과 비혼(`Not Married`)으로 범주를 조정하고자 하는 작업을 살펴보자.

- 결혼 상태코드: `MaritalStatus`
    - Divorced, Married, Never married, No answer, Separated, Widowed
- 혼인여부 상태코드: `BaseMarital`
    - 혼인(`Married`), 비혼(`Not Married`)

```{r GSS-martial-recode}
GSS$BaseMarital <- GSS$MaritalStatus
summary(GSS$BaseMarital)

levels(GSS$BaseMarital) <- c("Not Married", "Married",
                             "Not Married", "No answer",
                             "Not Married", "Not Married", NA)
summary(GSS$BaseMarital)
```

`tidyverse`로 깔끔하게 범주를 재지정하면 다음과 같다. 물론 `dplyr` 팩키지 `recode()` 함수를 사용한다.

```{r GSS-martial-recode-tidyverse}
GSS <- GSS %>%
  mutate(tidyMaritalStatus = recode(MaritalStatus,
    Divorced        = "Not Married",
    `Never married` = "Not Married",
    Widowed         = "Not Married",
    Separated       = "Not Married"))

summary(GSS$tidyMaritalStatus)
```

## 범주를 줄이기 {#forcats-bins}

범주가 많은 경우 이를 줄이거나, 숫자를 일정 범위로 묶어 범주화하는 경우가 많다.
숫자형 변수지만 값에 "No answer" 혹은 "89 or order"와 같이 문자가 들어 있는 경우 전체가 문자형이 되고 Base R에서는 요인형 변수로 전환된다.


```{r combine-discrete-levels}
GSS$BaseAge <- GSS$Age
levels(GSS$BaseAge)
```

Base R에서 먼저 `as.numeric`으로 자료를 변환시키고 나서 `ifelse()` 함수를 사용해서 범주화한다.

<div class = "row">
  <div class = "col-md-6">
**Base R 범주 줄이는 방법**

```{r change-factor-collapse-base}
GSS$BaseAge <- as.numeric(as.character(GSS$BaseAge))
summary(GSS$BaseAge)

GSS$BaseAge <- ifelse(GSS$BaseAge < 65, "18-64", "65 and up")
GSS$BaseAge <- factor(GSS$BaseAge)
summary(GSS$BaseAge)
```

  </div>
  <div class = "col-md-6">

**`tidyverse` 범주 줄이는 방법**

```{r change-factor-collapse-tidyverse}
GSS <- GSS %>%
  mutate(tidyAge = parse_number(as.character(Age))) %>%
  mutate(tidyAge = if_else(tidyAge < 65, "18-65", "65 and up"),
         tidyAge = factor(tidyAge))

summary(GSS$tidyAge)
```

  </div>
</div>

## 파생 요인 변수 생성시킴 {#conditional-case-when}

변수 조건에 따라 범주를 다시 재그룹화시키거나 숫자를 적당한 범위로 나눌 경우 `case_when()` 함수를 사용한다. 먼저 적당한 데이터를 생성시킨다. `mosaic` 팩키지에 `HELPmiss` 데이터셋이 포함되어 있다. 성별로 음주량에 대한 측정데이터가 담겨있다.

- `sex`: 성별
- `i1`: 지난 1달동안 하루 평균 섭취 음주량
- `i2`: 지난 1달동안 하루 평균 최대 섭취 음주량
- `age`: 나이

```{r change-factor-derived}
library(mosaic)
library(mosaicData)

data(HELPmiss)

HELPsmall <- HELPmiss %>%
  mutate(i1 = ifelse(id == 1, NA, i1)) %>% # make one value missing
  select(sex, i1, i2, age)

head(HELPsmall, 5)
```


<div class = "row">
  <div class = "col-md-6">
**Base R 파생 범주형 변수생성**

```{r derived-factor-collapse-base}
# create empty vector for new variable
drinkstat <- character(length(HELPsmall$i1))
# create abstinent group
drinkstat[HELPsmall$i1 == 0] = "abstinent"
# create moderate group
drinkstat[(HELPsmall$i1>0 & HELPsmall$i1<=1 & # find those with moderate levels
           HELPsmall$i2 <= 3 & HELPsmall$sex == "female") |
          (HELPsmall$i1 > 0 & HELPsmall$i1 <= 2 &
           HELPsmall$i2 <= 4 & HELPsmall$sex == "male")] = "moderate"
# create highrisk group
drinkstat[((HELPsmall$i1 > 1 | HELPsmall$i2 > 3) & HELPsmall$sex == "female") |
((HELPsmall$i1 > 2 | HELPsmall$i2 > 4) & HELPsmall$sex == "male")] = "highrisk"
# account for missing values
is.na(drinkstat) <- is.na(HELPsmall$i1) | is.na(HELPsmall$i2) |
is.na(HELPsmall$sex)
drinkstat <- factor(drinkstat)
table(drinkstat, useNA = "always")
```

  </div>
  <div class = "col-md-6">

**`tidyverse` 파생 범주형 변수생성**

```{r derived-factor-collapse-tidyverse}
HELPsmall <- HELPsmall %>%
  mutate(drink_stat = case_when( i1 == 0 ~ "abstinent",
                                 i1 <= 1 & i2 <= 3 & sex == 'female' ~ "moderate",
                                 i1 <= 1 & i2 <= 3 & sex == 'male' & age >= 65 ~ "moderate",
                                 i1 <= 2 & i2 <= 4 & sex == 'male' ~ "moderate",
                                 is.na(i1) ~ "missing", # cant put NA in place of "missing"
                                 TRUE ~ "highrisk"
))

HELPsmall %>%
  group_by(drink_stat) %>%
  dplyr::count()
```

  </div>
</div>


# 데이터셋 - 캐글 설문 {#ds-factor-forcats-kaggle}

[Wrangling categorical data in R](https://www.semanticscholar.org/paper/Wrangling-categorical-data-in-R-McNamara-Horton/1064bf4b820a877043a3bfb6c8481b230afc5b2b)에 포함된 [GSS 데이터셋](https://raw.githubusercontent.com/dsscollection/factor-mgmt/master/data/GSScleaned.csv)이 요인(factor) 자료구조를 다루는데 마치 `mtcars`, `iris`, `titanic`, `mnist`와 같은 역할을 하고 있다.

원데이터는 파일 크기가 20 메가바이트를 넘고 원본 데이터는 캐글 [Kaggle ML and Data Science Survey, 2017](https://www.kaggle.com/kaggle/kaggle-survey-2017) 설문조사 학습플랫폼 설문문항로 전형적인 설문문항의 한 사례로 볼 수 있다.


--------


데이터를 가져와서 특정 변수만 추출하고 `select(contains("LearningPlatformUsefulness"))`,
폭넓은 자료형태(wide)를 긴 자료형태(long)로 변형시킨다.
그리고 나서 `mutate_if()` 함수로 문자형자료형을 요인형자료형으로 변형시키고 나서 데이터를 정제시킨다.

``` {r kaggle-case-forcats}
# 0. 환경설정 -----
library(tidyverse)
library(extrafont)
loadfonts()

# 1. 데이터 -----

# kaggle_dat <- read_csv("https://raw.githubusercontent.com/bkaniskan/KaggleDSsurvey/master/data/multipleChoiceResponses.csv")

kaggle_dat <- read_csv("https://github.com/mbzhuang/Kaggle-ML-and-Data-Science-Survey-Analysis/blob/master/RawData/multipleChoiceResponses.csv?raw=true")

## 1.1. 데이터 정제 -----
kaggle_df <- kaggle_dat %>% 
    select(contains("LearningPlatformUsefulness")) %>% 
    gather(platform, value) %>% 
    mutate_if(is.character, as.factor) %>% 
    mutate(platform = str_remove(platform, "LearningPlatformUsefulness")) %>% 
    filter(!is.na(value))
```

플랫폼별로 빈도수를 조사한 후에 요인형 변수를 수준(level) 조정을 하고 시각화가 깔끔하게 될 수 있도록 라벨명을 조정한다.

``` {r kaggle-case-forcats-cleansing}
## 1.2. 요인형 자료 -----
kaggle_cat_df <- kaggle_df %>% 
    group_by(platform) %>% 
    count(value) %>% 
    add_count(platform, wt=n, name="nn") %>%
    mutate(pcnt = n / nn) %>% 
    mutate(value = fct_relevel(value, "Not Useful", "Somewhat useful", "Very useful")) %>% 
    mutate(value = case_when(
        str_detect(value, "Somewhat") ~ "Somewhat",
        str_detect(value, "Not") ~ "Not useful",
        str_detect(value, "Very") ~ "Very useful"
    ))
```

작은 창에 각 학습플랫폼별로 내용을 잘 나타날 수 있도록 시각화한다.

``` {r kaggle-case-forcats-viz, fig.width=12, fig.height=9}
# 2. 탐색적 데이터 분석 -----
## 2.1. 시각화 -----
kaggle_cat_df %>% 
    ggplot(aes(x=value, y=pcnt, group=platform)) +
      geom_line() +
      geom_point() +
      facet_wrap(~platform)  +
      theme_minimal(base_family = "NanumGothic") +
      scale_y_continuous(labels = scales::percent) +
      labs(x="", y="응답 비율", title="캐글 설문조사", 
           subtitle = "학습 플랫폼별 유용성 설문",
           caption = "자료출처: Kaggle ML and Data Science Survey, 2017(https://www.kaggle.com/kaggle/kaggle-survey-2017)")
```


# `forcats` 팩키지 [^forcats-pkg] {#ds-factor-forcats}

[^forcats-pkg]: [forcats: Tools for Working with Categorical Variables (Factors)](https://cran.r-project.org/web/packages/forcats/index.html)

정성적 변수와 더불어 데이터 분석과 모형개발에서 필히 익숙하게 다뤄야 하는 데이터가 범주형 데이터다.
과거 `install.packages("tidyverse")`, `install.packages("forcats")` 명령어를 통해서 
`library(tidyverse)`, `library(forcats)`를 통해서 명시적으로 팩키지를 불러와서 적재했으나, 
이제는 별도로 설치해서 적재할 필요는 없다. 이유는 현시점 기준 `tidyverse`의 핵심 일원이 되었기 때문이다.

범주형 데이터를 처리하는 요인(factor) 자료형을 이해하고, `tidyverse` 생태계에서 범주형 요인을 담당하는 `forcats` 팩키지를 통해서
범주형 데이터를 자유자재로 다룰 수 있는 역량을 익히자.

# 요인(factor) 기초 [^r4ds-factor] {#ds-factor-forcats-basic}

[^r4ds-factor]: [R for Data Science, 15 Factors](http://r4ds.had.co.nz/factors.html)

요인형 자료형을 문자형 대신 사용하게 되면 두가지 장점이 있는데, 가장 큰 장점은 아마도 오탈자로 생기는 새로운 유형 생성을 억제시킬 수 있다.
즉, 월은 12개월 밖에 존재하지 않는다. 따라서, 오탈자로 인해 범주가 추가로 생성되는 것을 사전에 방지할 수 있다.
그리고, 요인형을 자료형을 갖추게 되면 정렬을 쉽게 할 수도 있다.

일반 문자형 벡터을 정렬하게 되면 알파벳순으로 정렬하는데 무의미하다.

``` {r create-factor}
library(tidyverse)
x1 <- c("Dec", "Apr", "Jan", "Mar")
sort(x1)
```

`levels` 인자로 수준을 정의하게 되면 오탈자로 인한 엉뚱한 범주가 추가되는 것을 방지하는 것과 더불어 
정렬하게 되면 사람에게 좀더 의미있게 다가온다.

``` {r create-level-in-factor}
month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")

y1 <- factor(x1, levels = month_levels)
y1
sort(y1)
```

`x2` 문자열 벡터에 `Jam` 범주가 들어가 있는데 이를 `levels`를 통해 범주를 설정하게 되면 
오류를 방지할 수 있다. 특히, `parse_factor` 명령어를 사용하면 어디가 잘못되었는지 확인이 쉽다.

``` {r detect-level-error}
x2 <- c("Dec", "Apr", "Jam", "Mar")
y2 <- factor(x2, levels = month_levels)
y2
y2 <- parse_factor(x2, levels = month_levels)
```

`levels`를 생략하게 되면 기본디폴트 설정으로 알파벳순으로 범주를 생성하여 수준을 정해버린다.

``` {r default-levels-in-factor}
factor(x1)
```

수준(levels) 순서를 맞추려면 `unique()` 혹은 `fct_inorder()` 함수를 사용한다.

``` {r levels-in-order}
f1 <- factor(x1, levels = unique(x1))
f1

f2 <- x1 %>% factor() %>% fct_inorder()
f2

levels(f2)
```

# GSS(General Social Survey) 사례 {#ds-factor-gss}

미국 시카고 대학 독립적인 연구기관 NORC에서 장기적으로 수행하는 설문조사 [GSS(General Social Survey)](http://gss.norc.org/) 데이터를 
실습자료로 활용한다. `tidyverse`를 도서관(library)에서 꺼내와서 메모리에 올리게 되면 `gss_cat` 데이터가 포함되어 있다.

``` {r factor-gss-data}
gss_cat %>%
  DT::datatable()
```

## 범주형 변수 시각화 {#ds-factor-gss-race}

`forcats` 팩키지에 포함되어 있는 데이터로 원하는 경우 `? gss-cat` 명령어를 통해 데이터에 대한 자세한 내용을 확인할 수 있다.
`gss_cat` 데이터프레임에 포함되어 있는 `race`변수는 `is.factor()` 함수로 요인형으로 이를 막대그래프로 표현해보자.

`ggplot2`에서 기본디폴트 설정으로 어떤 값도 없는 수준은 자동으로 `drop` 시킨다. 
만약 변수에 포함된 모든 수준을 보려면 `drop=FALSE`를 넣어 명시적으로 작성한다.


<div class = "row">
  <div class = "col-md-6">
** 수준(level) 자동 제거**

``` {r factor-gss-race}
ggplot(gss_cat, aes(race)) +
  geom_bar()
```  

  </div>
  <div class = "col-md-6">
**숨은 수준 명시적 표현**

``` {r factor-gss-race-drop-levels}
ggplot(gss_cat, aes(race)) +
  geom_bar() +
  scale_x_discrete(drop = FALSE)
```

  </div>
</div>

## 단변량 범주형 변수  {#ds-factor-gss-only-one}


막대그래프의 경우 `fct_infreq()` 함수를 사용해서 오름 빈도수로 정렬이 가능하다: `fct_rev()`와 조합해서 사용해도 좋다.
`gss_cat` 데이터에서 요인 수준을 조정하는데 빈도순으로 오름차순으로 요인을 `fct_infreq()`로 정렬하고 나서,
`fct_rev()` 함수로 빈도수가 높은 순부터 역으로 요인 수준을 정렬하고 이를 시각화한다.

범주형 변수 결혼상태(`marital`)는 총 `r nlevels(gss_cat$marital) `개 수준이 있는데 빈도수가 다르기 때문에 
가장 높은 빈도수부터 낮은 빈도수를 갖는 결혼상태로 정렬한 후에 `ggplot()`으로 막대그래프를 작성한다.

``` {r factor-gss-barplot}
gss_cat %>%
  mutate(marital = marital %>% fct_infreq() %>% fct_rev()) %>%
  ggplot(aes(marital)) +
    geom_bar()
```

## 범주형 변수 필수기능 두가지 [^r-for-journalism] {#ds-factor-gss-absolute-two}

[^r-for-journalism]: [R FOR JOURNALISTS](https://learn.r-journalism.com/)

요인과 관련되어 가장 많이 사용하는 기능은 다음과 같다.

- 수준 순서를 바꿔 조정함
- 수준내부 값을 뭉개거나 변경시키는 변화

수준을 조정하지 않는 경우 전반적인 패턴을 살펴보기 어렵다. 하지만, 수준 순서를 재조장하게 되면 가독성을 훨씬 높일 수 있다.
`fct_reorder()` 함수를 사용하는데 인자가 세개 필요하다.

- `f`, 수준을 변경하려는 요인명
- `x`, 수준을 변경하는데 사용되는 숫자 벡터에
- `fun`, `f` 값 각각에 대해 다수 값이 있는 경우 이를 요약할 함수, 기본디폴트 함수는 중위수를 산출하는 함수 `median`.


<div class = "row">
  <div class = "col-md-6">
** 수준(level) 순서를 변경전**

``` {r factor-gss-change-levels}
relig <- gss_cat %>%
  group_by(relig) %>%
  summarise(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )

ggplot(relig, aes(tvhours, relig)) + geom_point()
```

  </div>
  <div class = "col-md-6">
** 수준(level) 순서를 가독성 높게 적용**

``` {r factor-gss-change-level}
ggplot(relig, aes(tvhours, fct_reorder(relig, tvhours))) +
  geom_point()
```  
  </div>
</div>


먼저 `mutate()`로 요인 수준을 뽑아내서 수준을 재조정한 후에 `aes()` 함수에서 넣는 것도 가능합니다.

``` {r factor-gss-reorder-levels, eval=FALSE}
relig %>%
  mutate(relig = fct_reorder(relig, tvhours)) %>%
  ggplot(aes(tvhours, relig)) +
    geom_point()
```

종교별 TV 시청시간에 대한 실제품으로 사용으로 될 수 있도록 마무리를 해보자.
이를 위해서 `geom_segment()` 함수를 활용하여 직선을 추가한다.
그리고 기타 색상과 점크기를 조정하고 x축과 y축에 대한 라벨과 제목을 추가한다.

``` {r factor-gss-reorder-levels-polishing}
ggplot(relig, aes(tvhours, fct_reorder(relig, tvhours))) +
    geom_point(color="red", size=3.5, alpha=0.7) +
    # geom_segment(
    #     aes(x = 0,
    #         y=fct_reorder(relig, tvhours, desc=TRUE),
    #         xend = tvhours,
    #         yend = fct_reorder(relig, tvhours, desc=TRUE)),
    #     color = "pink",
    #     linetype = "dashed",
    #     size = 1) +
    theme_minimal(base_family = "NanumGothic") +
    labs(x="TV 시청시간", y="종교", title="종교별 TV 시청시간")
```

## 요인변수 내부 명칭 변경 {#ds-factor-recode}

요인변수 내부 수준을 바꾸거나 뭉개서 합치는 기능이 자주 사용되고 있다.
먼저 범주형변수 내부 수준(level)의 명칭을 변경사흔데 `fct_recode()` 함수를 사용한다.
특히, 시각화를 할 때 범주형변수 수준이 길거나 가독성이 떨어지는 경우 요인변수 수준명칭을 바뀌는 것이 필수적이다.

`fct_recode()` 함수는 명시적으로 언급되지 않는 수준을 그대로 두고, 존재하지 않는 수준을 우연히 언급할 경우 경고 메시지를 띄운다.

``` {r factor-gss-recode}
gss_cat %>% count(partyid)
```

<div class = "row">
  <div class = "col-md-6">
**요인 수준 명칭 변경 사례**

``` {r factor-gss-recode-case}

gss_cat %>%
  mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat"
  )) %>%
  count(partyid)
```

  </div>
  <div class = "col-md-6">
**요인 수준 변경시 경고 사례**

``` {r factor-gss-recode2, warning=TRUE, message=TRUE}
gss_cat %>%
  mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat",
    "Other"                 = "No answer",
    "Other"                 = "Don't know",
    "Other"                 = "Other party"
  )) %>%
  count(partyid)
```

  </div>
</div>



## 범주형 수준 조정 {#ds-factor-gss-absolute-two-relevel}

`fct_collapse()` 함수는 `fct_recode()`함수의 변종으로 매우 유용하다.
범주형 데이터를 분석할 경우 범주형 변수의 수준을 합쳐야 하는 경우가 종종 발생된다.
충청북도와 충청남도를 합쳐 충청도로 하거나 충청도의 대전광역시와 세종특별자치시를 
충청도에 포함시키는 경우도 이런 유형의 작업에 해당된다.

`fct_collapse()` 함수에 합쳐질 수준을 정의하면 명시적으로 수준을 보고좋게 정리할 수 있다.


``` {r factor-gss-collapse}
gss_cat %>%
  mutate(partyid = fct_collapse(partyid,
    other = c("No answer", "Don't know", "Other party"),
    rep = c("Strong republican", "Not str republican"),
    ind = c("Ind,near rep", "Independent", "Ind,near dem"),
    dem = c("Not str democrat", "Strong democrat")
  )) %>%
  count(partyid)
```

복잡한 데이터셋을 다룰 경우 처리할 변수가 상당히 많은 경우가 있다. 이런 경우 `fct_lump()` 함수가 유용하다.
범주내 수준에 작은 값이 할당된 경우 이를 합쳐 의미있는 수준에 대한 값이 되도록 만드는 기능을 수행한다. `n=10`으로 인자값을 넣어주면 해당 변수에 수준이 10개로 지정된다.
상황에 따라서는 `fct_lump()`함수에 인자로 `prob=0.1`와 같이 확률이 10% 미만이 되는 것은 모두 기타에 넣는 것도 가능하다. `other_level="기타"`를 넣어 합쳐지는 수준에 대한 명칭을 별도로 지정하는 것도 가능하다.

``` {r factor-gss-lump, warning=FALSE}
gss_cat %>%
  mutate(relig = fct_lump(relig, n = 10, other_level = "기타" )) %>%
  count(relig, sort = TRUE) %>%
  print(n = Inf)
```


